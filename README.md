# Enhanced PS1 SRS: Development Blueprint\n\n**Version:** 1.0\n\n**Description:** A detailed, step-by-step plan for building the Enhanced PS1 Spaced Repetition System, broken down into iterative chunks and actionable tasks for developers.\n\n---\n\n# Phase 0: Setup, Planning & Foundation\n\n**Goal:** Establish team, environment, repository, and understand PS1 baseline.\n\n---\n\n## P0-C1: Team & Environment Setup\n\n**Goal:** Ensure all developers have the necessary tools and communication channels.\n\n- [ ] **P0-C1-S1:** Finalize team members and roles (flexible).\n  - *Details:* Confirm who is on the team. Assign initial focus areas if helpful (e.g., Ext Lead, TF Lead).\n- [ ] **P0-C1-S2:** Establish Communication Channels.\n  - *Details:* Set up Slack/Discord/etc. Define meeting schedule (e.g., daily standup).\n- [ ] **P0-C1-S3:** Install Required Software.\n  - *Details:* Ensure Node.js, npm (or yarn), TypeScript (`npm install -g typescript`), and Git are installed and versions are compatible.\n- [ ] **P0-C1-S4:** Set Up Code Editor.\n  - *Details:* Standardize on VS Code (recommended). Install extensions: Prettier, ESLint, GitLens, potentially language-specific helpers.\n\n---\n\n## P0-C2: Repository & Git Workflow Setup\n\n**Goal:** Create the central code repository and establish branching/commit practices.\n\n- [ ] **P0-C2-S1:** Create Central Git Repository.\n  - *Details:* Create a new repository on GitHub/GitLab. Add initial project files (e.g., `.gitignore` for Node, basic `package.json`).\n- [ ] **P0-C2-S2:** Define & Practice Branching Strategy.\n  - *Details:* Adopt strategy: `main` (stable), `develop` (integration), `feature/<name>` (work). Create `develop` branch from `main`. All new work starts from `develop`.\n- [ ] **P0-C2-S3:** Initialize Project & First Commit.\n  - *Details:* Clone the repository. Run `npm init -y`. Add basic config files (`tsconfig.json`, `.prettierrc`, `.eslintrc.js`). Commit these initial files to `develop` following the workflow (create `feature/initial-setup`, commit, push, PR, merge).\n\n---\n\n## P0-C3: PS1 Analysis & Initial Design\n\n**Goal:** Understand the existing PS1 code and sketch the high-level architecture.\n\n- [ ] **P0-C3-S1:** Obtain and Analyze PS1 Code.\n  - *Details:* Clone or copy the relevant PS1 source code into the new repository (or structure project to import it).\n- [ ] **P0-C3-S2:** Review PS1 ADTs (Card, Deck).\n  - *Details:* Read the code for `Card` and `Deck`. Identify Spec, AF, RI, checkRep, public methods, and data structure. Understand the core SRS logic.\n- [ ] **P0-C3-S3:** Identify Integration Points.\n  - *Details:* Discuss and document: How will a new card be added? How will review status be updated? Where will the `Deck` instance live initially?\n- [ ] **P0-C3-S4:** Sketch High-Level Architecture.\n  - *Details:* Use a whiteboard or tool (Excalidraw) to draw components (Extension [Content, Popup], Hand Pose Module, PS1 Core, Backend [Future], DB [Future]) and data flow arrows between them.\n- [ ] **P0-C3-S5:** Document Initial Decisions.\n  - *Details:* Create/update `README.md` or a design document with architecture sketch, PS1 analysis notes, initial tech choices, and integration point decisions.\n\n---\n\n# Phase 1: Browser Extension - Card Creation (In-Memory)\n\n**Goal:** Build the basic extension to capture text and save cards to an in-memory Deck.\n\n---\n\n## P1-C1: Extension Manifest & Basic Structure\n\n**Goal:** Create the core files and manifest for a loadable extension.\n\n- [ ] **P1-C1-S1:** Create `manifest.json` (Spec First).\n  - *Details:* Create `manifest.json` in project root or `/extension` dir. Define `manifest_version: 3`, `name`, `version`, `description`. Specify `action.default_popup: \"popup.html\"`. Request `permissions: [\"activeTab\", \"scripting\"]`.\n- [ ] **P1-C1-S2:** Create Basic `popup.html`.\n  - *Details:* Create a minimal HTML file (`popup.html`) with a body, maybe a title (`<h1>`). Link `popup.js` (`<script src=\"popup.js\" defer>`).\n- [ ] **P1-C1-S3:** Create Empty `popup.js` and `content.js`.\n  - *Details:* Create placeholder JavaScript files.\n- [ ] **P1-C1-S4:** Define Content Script in Manifest.\n  - *Details:* Add `content_scripts` section to `manifest.json`, specifying `matches: [\"<all_urls>\"]` (or more specific) and `js: [\"content.js\"]`.\n- [ ] **P1-C1-S5:** Test: Load Unpacked Extension.\n  - *Details:* Enable developer mode in Chrome/Firefox. Use 'Load unpacked' to load the extension directory. Verify the extension icon appears and the popup opens (shows basic HTML). Check for manifest errors.\n- [ ] **P1-C1-S6:** Git: Commit Skeleton.\n  - *Details:* Create `feature/extension-skeleton` branch. Commit manifest, HTML, JS files. Create PR, review, merge to `develop`.\n\n---\n\n## P1-C2: Text Capture (Content Script -> Popup)\n\n**Goal:** Implement the mechanism to get selected text from the page into the popup.\n\n- [ ] **P1-C2-S1:** Implement Content Script Listener.\n  - *Details:* In `content.js`, add `chrome.runtime.onMessage.addListener((message, sender, sendResponse) => { ... })`. Inside, check if `message.type === 'GET_SELECTED_TEXT'`. If so, get text via `document.getSelection().toString()` and call `sendResponse({ selectedText: text })`. Log received messages and responses.\n- [ ] **P1-C2-S2:** Implement Popup Text Request.\n  - *Details:* In `popup.js`, add code to run when the popup opens. Use `chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => { ... })` to get the active tab ID. Inside the callback, use `chrome.tabs.sendMessage(tabs[0].id, { type: 'GET_SELECTED_TEXT' }, (response) => { ... })`.\n- [ ] **P1-C2-S3:** Implement Popup Response Handling.\n  - *Details:* Inside the `sendMessage` callback in `popup.js`, check for errors (`chrome.runtime.lastError`). If no error and `response` exists, log `response.selectedText`.\n- [ ] **P1-C2-S4:** Update Popup HTML.\n  - *Details:* Add a text area (`<textarea id=\"card-front\" rows=\"4\" cols=\"30\"></textarea>`) to `popup.html`.\n- [ ] **P1-C2-S5:** Display Text in Popup.\n  - *Details:* Modify the `sendMessage` callback in `popup.js` to set the value of the `#card-front` textarea with `response.selectedText`.\n- [ ] **P1-C2-S6:** Test: Text Capture Flow.\n  - *Details:* Reload extension. Select text on a webpage. Open popup. Verify selected text appears in the 'front' text area. Test with no selection. Check console logs in both content script (page devtools) and popup (popup devtools).\n- [ ] **P1-C2-S7:** Git: Commit Text Capture Feature.\n  - *Details:* Create `feature/text-capture` branch. Commit changes. Create PR, review, merge to `develop`.\n\n---\n\n## P1-C3: In-Memory Card Save\n\n**Goal:** Integrate PS1 ADTs and save created cards to an in-memory Deck.\n\n- [ ] **P1-C3-S1:** Integrate PS1 ADTs.\n  - *Details:* Copy or import the PS1 `Card.ts` and `Deck.ts` (or JS equivalents) into your project structure (e.g., `src/srs`). Ensure they are compilable/usable (might require minor TS adjustments or build step).\n- [ ] **P1-C3-S2:** Instantiate Deck in Popup.\n  - *Details:* In `popup.js`, import `Deck`. Create a single Deck instance at the top level: `const deck = new Deck();`. (Note: This is temporary state).\n- [ ] **P1-C3-S3:** Add Save UI Elements.\n  - *Details:* In `popup.html`, add a second text area (`<textarea id=\"card-back\" ...>`) and a save button (`<button id=\"save-card\">Save Card</button>`). Add a status message area (`<p id=\"status-message\"></p>`).\n- [ ] **P1-C3-S4:** Implement Save Button Logic.\n  - *Details:* In `popup.js`, add an event listener to `#save-card`. Inside the listener: \n    1. Get `frontText` from `#card-front` and `backText` from `#card-back`.\n    2. Basic Validation: Check if `frontText` and `backText` are non-empty. If not, show error in status message and return.\n    3. Import `Card`. Create `const newCard = new Card(frontText, backText);` (adjust constructor as per PS1).\n    4. Call `deck.addCard(newCard);`.\n    5. Log success: `console.log('Card added. Deck size:', deck.getCardCount());`.\n    6. Provide UI feedback: Clear text areas, show success message in `#status-message`.\n- [ ] **P1-C3-S5:** Test: Card Saving Flow.\n  - *Details:* Reload extension. Capture text, fill in back, click Save. Check console log for deck size increase. Verify UI feedback. Try saving multiple cards. Test validation for empty fields.\n- [ ] **P1-C3-S6:** Refactor (Optional): Move Deck to Background Worker.\n  - *Details:* If aiming for better state persistence (while browser open): \n    1. Define `background.js` in manifest.\n    2. Move Deck instantiation to `background.js`.\n    3. Refactor save logic in `popup.js` to send 'saveCard' message with data to background.\n    4. Implement message listener in `background.js` to call `deck.addCard`. (This adds complexity, can defer).\n- [ ] **P1-C3-S7:** Git: Commit In-Memory Save Feature.\n  - *Details:* Create `feature/in-memory-save` branch. Commit changes. Create PR, review, merge to `develop`.\n\n---\n\n# Phase 2: Hand Pose Integration (In-Memory)\n\n**Goal:** Implement webcam-based gesture control for reviewing cards from the in-memory Deck.\n\n---\n\n## P2-C1: Webcam & TensorFlow.js Setup\n\n**Goal:** Access webcam and load the hand pose detection model.\n\n- [ ] **P2-C1-S1:** Add Dependencies.\n  - *Details:* Run `npm install @tensorflow/tfjs @tensorflow-models/hand-pose-detection`.\n- [ ] **P2-C1-S2:** Add Video Element.\n  - *Details:* In `popup.html`, add `<video id=\"webcam-feed\" width=\"160\" height=\"120\" autoplay muted playsinline></video>`. Add loading status element `<p id=\"tf-status\">Loading...</p>`.\n- [ ] **P2-C1-S3:** Implement Webcam Access.\n  - *Details:* In `popup.js`, write an async function `setupWebcam()`:\n    1. Get video element: `const video = document.getElementById('webcam-feed');`.\n    2. Use `navigator.mediaDevices.getUserMedia({ video: true })` in a try/catch block.\n    3. On success: `video.srcObject = stream;`.\n    4. On failure: Log error, display error message in `#tf-status`, handle permission denial gracefully.\n- [ ] **P2-C1-S4:** Implement Model Loading.\n  - *Details:* In `popup.js`, import `* as tf from '@tensorflow/tfjs';` and `* as handPoseDetection from '@tensorflow-models/hand-pose-detection';`.\n    Write an async function `loadHandPoseModel()`:\n    1. Set status: `#tf-status`.textContent = 'Loading model...';\n    2. Create detector: `const model = await handPoseDetection.createDetector(handPoseDetection.SupportedModels.MediaPipeHands, { runtime: 'tfjs' });` in try/catch.\n    3. On success: Store `model` instance globally (or in module scope), set status: `#tf-status`.textContent = 'Model loaded.'; return model.\n    4. On failure: Log error, set status: `#tf-status`.textContent = 'Model load failed.'; return null.\n- [ ] **P2-C1-S5:** Orchestrate Setup.\n  - *Details:* In `popup.js`, call `setupWebcam()` and `loadHandPoseModel()` when the popup initializes. Handle the promises appropriately (e.g., using `Promise.all` or async/await). Store the loaded model and video element reference.\n- [ ] **P2-C1-S6:** Test: Webcam and Model Load.\n  - *Details:* Reload extension, open popup. Verify it asks for webcam permission. Verify video feed appears. Verify status message updates correctly for model loading/success/failure.\n- [ ] **P2-C1-S7:** Git: Commit TF.js Setup.\n  - *Details:* Create `feature/tfjs-setup` branch. Commit changes. Create PR, review, merge to `develop`.\n\n---\n\n## P2-C2: Hand Detection Loop\n\n**Goal:** Continuously detect hand landmarks from the video feed.\n\n- [ ] **P2-C2-S1:** Implement Detection Loop Function.\n  - *Details:* In `popup.js`, create an async function `detectHandsLoop(model, video)`:\n    1. Check if `model` and `video` are ready.\n    2. Call `const hands = await model.estimateHands(video);`.\n    3. If `hands.length > 0`: `console.log(hands[0].keypoints);` (Log landmarks for now).\n    4. Use `requestAnimationFrame(() => detectHandsLoop(model, video));` to schedule the next frame.\n- [ ] **P2-C2-S2:** Start the Loop.\n  - *Details:* After both webcam and model are successfully set up (in the orchestration step P2-C1-S5), call `detectHandsLoop(loadedModel, videoElement);` once to start it.\n- [ ] **P2-C2-S3:** Test: Landmark Detection.\n  - *Details:* Reload extension, open popup. Place hand in front of webcam. Check popup console for arrays of keypoint data being logged continuously.\n- [ ] **P2-C2-S4:** Git: Commit Detection Loop.\n  - *Details:* Create `feature/detection-loop` branch. Commit changes. Create PR, review, merge to `develop`.\n\n---\n\n## P2-C3: Gesture Recognizer ADT\n\n**Goal:** Create and test the logic to translate landmarks into gestures.\n\n- [ ] **P2-C3-S1:** Create `GestureRecognizer.ts`.\n  - *Details:* Create the file (e.g., `src/srs/GestureRecognizer.ts`).\n- [ ] **P2-C3-S2:** Define Types and Enum.\n  - *Details:* Inside the file, define `enum Gesture { ThumbsUp, ThumbsDown, FlatHand, Unknown }`. Define `Keypoint` type (or import).\n- [ ] **P2-C3-S3:** Write Spec, AF, RI for `GestureRecognizer` Class.\n  - *Details:* Define the class. Add comments specifying the `recognizeGesture(landmarks: Keypoint[]): Gesture` method. Detail the geometric conditions for *simple* versions of Thumbs Up, Thumbs Down, Flat Hand based on landmark indices (e.g., thumb tip Y vs MCP Y). Define AF/RI.\n- [ ] **P2-C3-S4:** Implement `recognizeGesture` Logic.\n  - *Details:* Write the TypeScript code to compare landmark coordinates based on the spec. Return the corresponding `Gesture` enum or `Gesture.Unknown`.\n- [ ] **P2-C3-S5:** Set up Unit Testing (Jest).\n  - *Details:* Run `npm install --save-dev jest @types/jest ts-jest`. Create `jest.config.js`. Add test script to `package.json`.\n- [ ] **P2-C3-S6:** Write Unit Tests for `GestureRecognizer`.\n  - *Details:* Create `GestureRecognizer.test.ts`. Import the class. Create mock `Keypoint[]` data representing clear examples of Thumbs Up, Thumbs Down, Flat Hand, ambiguous poses, and no landmarks. Write tests using `expect(recognizer.recognizeGesture(mockData)).toBe(Gesture.ThumbsUp);` etc.\n- [ ] **P2-C3-S7:** Implement `checkRep()` (Optional).\n  - *Details:* Add a `checkRep` method if the ADT has internal state or thresholds to validate.\n- [ ] **P2-C3-S8:** Run Tests and Debug.\n  - *Details:* Run `npm test`. Debug the `recognizeGesture` logic and tests until all tests pass.\n- [ ] **P2-C3-S9:** Git: Commit Gesture Recognizer ADT.\n  - *Details:* Create `feature/gesture-recognizer-adt` branch. Commit ADT code and tests. Create PR, review (focus on spec/test alignment), merge to `develop`.\n\n---\n\n## P2-C4: Integrate Gestures & Review Flow\n\n**Goal:** Use recognized gestures to update the review status of cards in the in-memory Deck.\n\n- [ ] **P2-C4-S1:** Add Review UI Elements.\n  - *Details:* In `popup.html`, add elements to display card front (`<div id='review-front'></div>`), card back (`<div id='review-back'></div>`), a 'Show Answer' button, and a 'Next Card' button (or trigger next automatically). Add element to show recognized gesture (`<p id='gesture-status'></p>`).\n- [ ] **P2-C4-S2:** Implement Card Display Logic.\n  - *Details:* In `popup.js`, add function `displayCardForReview()`:\n    1. Get next card: `const currentCard = deck.getNextCardToReview();` (Adapt or implement `getNextCardToReview` in Deck if needed).\n    2. Store `currentCard` reference.\n    3. Display `currentCard.front` in `#review-front`, hide `#review-back`.\n    4. Handle case where no cards are due.\n- [ ] **P2-C4-S3:** Implement 'Show Answer' Logic.\n  - *Details:* Add event listener to 'Show Answer' button. When clicked, display `currentCard.back` in `#review-back`.\n- [ ] **P2-C4-S4:** Instantiate and Use `GestureRecognizer`.\n  - *Details:* In `popup.js`, import `GestureRecognizer`. Create instance `const gestureRecognizer = new GestureRecognizer();`. Inside `detectHandsLoop`, if `hands.length > 0`, call `const gesture = gestureRecognizer.recognizeGesture(hands[0].keypoints);`. Display the result in `#gesture-status`.\n- [ ] **P2-C4-S5:** Implement Debouncing Logic.\n  - *Details:* Add state variables: `lastDetectedGesture = null`, `gestureConfidence = 0`, `REQUIRED_CONFIDENCE = 3`. In `detectHandsLoop`, if `gesture !== Gesture.Unknown` and `gesture === lastDetectedGesture`, increment `gestureConfidence`. If `gesture !== lastDetectedGesture`, reset `gestureConfidence = 1`, update `lastDetectedGesture = gesture`. Only proceed if `gestureConfidence === REQUIRED_CONFIDENCE`.\n- [ ] **P2-C4-S6:** Implement Gesture-to-Review Mapping.\n  - *Details:* After debouncing check, if a valid gesture is confirmed:\n    1. Map gesture to review result: `ThumbsDown -> 0 (Wrong)`, `FlatHand -> 1 (Hard)`, `ThumbsUp -> 2 (Easy)`.\n    2. If `currentCard` exists, call `deck.updateCardReview(currentCard, reviewResult);`.\n    3. Log the update: `console.log('Card reviewed:', currentCard, 'Result:', reviewResult);`.\n    4. Reset `gestureConfidence = 0` to prevent immediate re-trigger.\n    5. Trigger display of the next card: Call `displayCardForReview()`.\n- [ ] **P2-C4-S7:** Test: Full Gesture Review Flow.\n  - *Details:* Reload extension. Add a few cards. Open popup, ensure webcam/model load. A card front should display. Make gestures: Thumbs Down, Flat Hand, Thumbs Up. Verify the gesture is recognized (after debounce), the correct review result is logged, and the next card appears. Test edge cases (no cards due).\n- [ ] **P2-C4-S8:** Refine Gesture Recognition.\n  - *Details:* Based on testing, adjust thresholds or logic in `GestureRecognizer` for better accuracy. Update unit tests accordingly.\n- [ ] **P2-C4-S9:** Git: Commit Gesture Review Feature.\n  - *Details:* Create `feature/gesture-review` branch. Commit changes. Create PR, review, merge to `develop`.\n\n---\n\n# Phase 3: Backend & Database Integration\n\n**Goal:** Persist card data using a Node.js/Express backend and Postgres database.\n\n---\n\n## P3-C1: Backend Server & API Skeleton\n\n**Goal:** Set up a basic Node.js/Express server with placeholder API routes.\n\n- [ ] **P3-C1-S1:** Set up Backend Directory Structure.\n  - *Details:* Create a `/server` directory. Inside, run `npm init -y`. Install dependencies: `npm install express cors dotenv`. Install dev dependencies: `npm install -D typescript @types/express @types/cors @types/node ts-node-dev nodemon`. Create `tsconfig.json` for server.\n- [ ] **P3-C1-S2:** Create Basic Express Server (`server/src/server.ts`).\n  - *Details:* Import express, cors. Create app instance. Use `cors()`. Define basic GET `/` route. Start server listening on port from `process.env.PORT` or default (e.g., 3001). Add `start:dev` script in `package.json` using `ts-node-dev`.\n- [ ] **P3-C1-S3:** Define Placeholder API Routes.\n  - *Details:* Create router file (e.g., `server/src/routes/cardRoutes.ts`). Define placeholder routes for: \n    - `POST /api/cards` -> `res.status(201).send('Card created (placeholder)')`\n    - `GET /api/cards` -> `res.status(200).json([])`\n    - `PUT /api/cards/:id/review` -> `res.status(200).send('Card reviewed (placeholder)')`\n    - `DELETE /api/cards/:id` -> `res.status(204).send()`\n    Mount router in `server.ts`.\n- [ ] **P3-C1-S4:** Test: Run Server & Hit Endpoints.\n  - *Details:* Run `npm run start:dev`. Use Postman/Insomnia/curl to hit the defined endpoints (GET, POST, PUT, DELETE). Verify placeholder responses and status codes.\n- [ ] **P3-C1-S5:** Git: Commit Backend Skeleton.\n  - *Details:* Create `feature/backend-skeleton` branch. Commit server code. Create PR, review, merge to `develop`.\n\n---\n\n## P3-C2: Database Setup & Connection\n\n**Goal:** Set up Postgres database and connect the backend server.\n\n- [ ] **P3-C2-S1:** Install & Set Up PostgreSQL.\n  - *Details:* Install Postgres locally (or use Docker/cloud service like ElephantSQL). Create a database (e.g., `srs_dev_db`) and a user/role for the application.\n- [ ] **P3-C2-S2:** Define Database Schema (SQL).\n  - *Details:* Create SQL script (`schema.sql`) to define the `cards` table as specified (id, front, back, interval, ease_factor, due_date, created_at, updated_at). Include `CREATE TABLE` statement.\n- [ ] **P3-C2-S3:** Apply Schema to Database.\n  - *Details:* Connect to the created database using `psql` or a GUI tool. Execute the `schema.sql` script to create the table.\n- [ ] **P3-C2-S4:** Install DB Driver.\n  - *Details:* In `/server`, run `npm install pg`. Install types: `npm install -D @types/pg`.\n- [ ] **P3-C2-S5:** Configure Database Connection.\n  - *Details:* Use `dotenv`. Create `.env` file in `/server` (add to `.gitignore`). Store `DATABASE_URL=postgresql://user:password@host:port/database`. Create DB connection module (e.g., `server/src/db.ts`) using `pg.Pool` and export the pool instance.\n- [ ] **P3-C2-S6:** Test: Database Connection.\n  - *Details:* In `server.ts` or a test script, import the pool and try a simple query (`pool.query('SELECT NOW()')`). Verify it connects successfully on server start.\n- [ ] **P3-C2-S7:** Git: Commit DB Setup.\n  - *Details:* Create `feature/db-setup` branch. Commit schema, connection logic, `.env.example`. Create PR, review, merge to `develop`.\n\n---\n\n## P3-C3: Backend API Implementation\n\n**Goal:** Implement the logic for API endpoints to interact with the database.\n\n- [ ] **P3-C3-S1:** Implement `POST /api/cards` Logic.\n  - *Details:* In card routes handler: \n    1. Validate request body (`req.body`) has `front` and `back` (use validation library or manual checks).\n    2. Use DB pool to `INSERT INTO cards (front, back) VALUES ($1, $2) RETURNING *`.\n    3. Handle DB errors.\n    4. Return `201 Created` with the newly created card data.\n- [ ] **P3-C3-S2:** Implement `GET /api/cards` Logic.\n  - *Details:* In card routes handler: \n    1. Check for query parameters (e.g., `due`).\n    2. Construct `SELECT * FROM cards` query (add `WHERE due_date <= NOW()` if `due` parameter exists).\n    3. Execute query.\n    4. Handle DB errors.\n    5. Return `200 OK` with the array of cards.\n- [ ] **P3-C3-S3:** Implement `PUT /api/cards/:id/review` Logic.\n  - *Details:* In card routes handler: \n    1. Validate `req.params.id` and `req.body.reviewResult`.\n    2. Fetch the card by ID (`SELECT * FROM cards WHERE id = $1`). Handle Not Found.\n    3. Implement/Import SRS update logic (takes card data and reviewResult, returns new interval, easeFactor, dueDate).\n    4. Use DB pool to `UPDATE cards SET interval = $1, ease_factor = $2, due_date = $3, updated_at = NOW() WHERE id = $4 RETURNING *`.\n    5. Handle DB errors.\n    6. Return `200 OK` with the updated card data.\n- [ ] **P3-C3-S4:** Implement `DELETE /api/cards/:id` Logic.\n  - *Details:* In card routes handler: \n    1. Validate `req.params.id`.\n    2. Use DB pool to `DELETE FROM cards WHERE id = $1`.\n    3. Check result (affected rows) to ensure deletion occurred. Handle Not Found.\n    4. Handle DB errors.\n    5. Return `204 No Content`.\n- [ ] **P3-C3-S5:** Implement Centralized Error Handling.\n  - *Details:* Add Express error handling middleware to catch errors and send consistent JSON error responses.\n- [ ] **P3-C3-S6:** Write API Integration Tests.\n  - *Details:* Set up Jest + Supertest for backend. Write tests for each endpoint: send requests, check status codes, validate response bodies. Use a separate test database or transaction rollback.\n- [ ] **P3-C3-S7:** Test: Full API Functionality.\n  - *Details:* Run server. Use Postman/Insomnia and integration tests to verify all CRUD operations work correctly against the database.\n- [ ] **P3-C3-S8:** Git: Commit Backend Implementation.\n  - *Details:* Create `feature/backend-impl` branch. Commit API logic and tests. Create PR, review, merge to `develop`.\n\n---\n\n## P3-C4: Frontend API Integration\n\n**Goal:** Refactor the browser extension to use the backend API for persistence.\n\n- [ ] **P3-C4-S1:** Refactor Card Creation (Save Button).\n  - *Details:* In `popup.js`, modify the 'Save Card' listener:\n    1. Instead of `deck.addCard`, use `fetch('/api/cards', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ front: frontText, back: backText }) })` (replace URL with actual backend URL, maybe configurable).\n    2. Handle the promise: check `response.ok`, parse JSON body, handle success/error UI feedback based on response.\n- [ ] **P3-C4-S2:** Refactor Card Loading.\n  - *Details:* In `popup.js`, modify `displayCardForReview` (or initialization logic):\n    1. Remove reliance on in-memory `deck` for loading.\n    2. Use `fetch('/api/cards?due=today')` to get due cards.\n    3. Handle promise: parse JSON, store retrieved cards locally (e.g., `let dueCards = []; let currentCardIndex = 0;`).\n    4. Display the first due card. Handle case of no due cards.\n- [ ] **P3-C4-S3:** Refactor Card Review Update (Gesture).\n  - *Details:* In `popup.js`, modify the gesture-to-review mapping logic:\n    1. Get the ID of the `currentCard` being displayed.\n    2. Instead of `deck.updateCardReview`, use `fetch(\`/api/cards/\${currentCard.id}/review\`, { method: 'PUT', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ reviewResult: result }) })`.\n    3. Handle promise: check response, handle errors. On success, advance to the next card in the locally stored `dueCards` array.\n- [ ] **P3-C4-S4:** Add Loading and Error States to UI.\n  - *Details:* Enhance UI to show loading indicators during `fetch` calls. Display user-friendly error messages if API calls fail.\n- [ ] **P3-C4-S5:** Test: End-to-End Persistent Flow.\n  - *Details:* Run backend server. Reload extension. \n    1. Create several cards via extension. Verify they appear in the database.\n    2. Close and reopen popup/browser. Verify cards persist.\n    3. Review cards using gestures. Verify updates in the database (due dates change).\n    4. Test all error conditions (server down, bad requests).\n- [ ] **P3-C4-S6:** Git: Commit Frontend API Integration.\n  - *Details:* Create `feature/frontend-api-integration` branch. Commit refactored frontend code. Create PR, review, merge to `develop`.\n\n---\n\n# Phase 4: Deployment (Optional Bonus)\n\n**Goal:** Deploy the backend and database to the cloud.\n\n---\n\n## P4-C1: Deploy Database (AWS RDS)\n\n**Goal:** Create a managed Postgres instance on AWS RDS.\n\n- [ ] **P4-C1-S1:** Create RDS Instance.\n  - *Details:* Navigate AWS RDS console, launch Postgres instance (consider Free Tier). Configure settings (DB name, master user/pass).\n- [ ] **P4-C1-S2:** Configure Security Group.\n  - *Details:* Modify RDS security group to allow inbound connections on port 5432 from the future backend server's IP/security group (initially maybe your IP for testing).\n- [ ] **P4-C1-S3:** Apply Schema to RDS.\n  - *Details:* Connect to the RDS instance using connection details (endpoint, user, pass) via psql/GUI. Run `schema.sql`.\n- [ ] **P4-C1-S4:** Update Backend .env.\n  - *Details:* Update `DATABASE_URL` in backend `.env` (or deployment environment variables) to point to the RDS endpoint.\n\n---\n\n## P4-C2: Deploy Backend (AWS Elastic Beanstalk)\n\n**Goal:** Deploy the Node.js/Express application to Elastic Beanstalk.\n\n- [ ] **P4-C2-S1:** Prepare Backend for Deployment.\n  - *Details:* Add `build` script to server `package.json` (`tsc`). Add `.npmrc` if needed. Ensure Procfile or `start` script is correct for production.\n- [ ] **P4-C2-S2:** Create EB Application & Environment.\n  - *Details:* Use AWS EB console or CLI (`eb init`, `eb create`) to set up Node.js environment.\n- [ ] **P4-C2-S3:** Configure Environment Variables.\n  - *Details:* In EB configuration, set `DATABASE_URL`, `PORT`, `NODE_ENV=production`, etc.\n- [ ] **P4-C2-S4:** Deploy Code.\n  - *Details:* Use `eb deploy` or upload zip file. Monitor deployment status.\n- [ ] **P4-C2-S5:** Update EB Security Group.\n  - *Details:* Ensure EB instance security group can reach RDS security group on port 5432.\n- [ ] **P4-C2-S6:** Test Deployed API.\n  - *Details:* Use Postman/Insomnia to hit the public EB URL endpoints. Verify functionality.\n\n---\n\n## P4-C3: Configure Frontend for Deployed Backend\n\n**Goal:** Make the browser extension communicate with the deployed API.\n\n- [ ] **P4-C3-S1:** Update API Base URL.\n  - *Details:* In `popup.js` (or a config file), change the base URL for `fetch` calls from `http://localhost:3001` to the public EB URL.\n- [ ] **P4-C3-S2:** Rebuild/Reload Extension.\n  - *Details:* Rebuild extension if necessary. Reload the unpacked extension in the browser.\n- [ ] **P4-C3-S3:** Test End-to-End with Deployed Backend.\n  - *Details:* Repeat end-to-end tests (create, review cards) ensuring the extension interacts correctly with the deployed AWS resources.\n\n---\n\n# Phase 5: Continuous Practices & Polish\n\n**Goal:** Maintain code quality, documentation, and improve UX throughout the project.\n\n---\n\n## P5-C1: Ongoing Activities\n\n**Goal:** Integrate best practices into daily workflow.\n\n- [ ] **P5-C1-S1:** Write Tests Concurrently.\n  - *Details:* Write unit/integration tests as features are developed, not just at the end.\n- [ ] **P5-C1-S2:** Maintain Documentation.\n  - *Details:* Update README, Spec/AF/RI comments as code changes.\n- [ ] **P5-C1-S3:** Adhere to Git Workflow.\n  - *Details:* Use feature branches, frequent commits, descriptive messages, PRs, and code reviews consistently.\n- [ ] **P5-C1-S4:** Refactor Regularly.\n  - *Details:* Identify and improve complex or unclear code sections. Address code smells.\n- [ ] **P5-C1-S5:** Enhance Error Handling.\n  - *Details:* Add more specific error handling and user feedback as edge cases are found.\n- [ ] **P5-C1-S6:** Improve UX/UI.\n  - *Details:* Based on usage, refine popup layout, gesture feedback, and overall interaction flow.\n\n"
